// [1] 여기에 입력한 것은 자식이 직접 q,w를 가짐
class Hero {
    constructor(q, w) {
        this.q = q;
        this.w = w;
    }
}

let 조이4 = new Hero("통통별", "주문도둑");
let 사일러스4 = new Hero("사슬 후려치기", "국왕시해자");

console.log(조이4);
console.log(사일러스4);

/*
prototype : 유전자라고 생각
- protoype : object
- Hero.prototype.name = "ham" //(prototype유전자)부모에 추가했기에 자식들한테서 다 사용가능
*/

// [2] 여기에 입력한 것은 부모만 name:'ham'을 가짐
Hero.prototype.name = 'ham'; // Hero (부모)에 추가했기에
console.log(조이4.name); // 조이4(자식)에게서 ham 출력됨

//------------------------------------------------------------//

/*
부모 prototype에 있는 것을 자식이 사용 가능한 이유?
<object에서 자료출력할 때>
1. 직접 자료를 가지고 있으면 출력
2. 없으면 부모유전자까지 찾음
3. 없으면 부모의 부모유전자까지...계속해서
=> 프로토타입체인(prototype chain)
*/

let 어레이1 = [3, 2, 1];
let 어레이2 = new Array(3, 2, 1); //위아래 동일 / 컴퓨터입장에서는 아래가 편함

console.log(어레이1.sort()) // (3)[1,2,3] / 가능한 이유는 Array prototype 있기 때문

// 모든 array에서 사용할 수 있는 함수를 만들고 넣으려면 prototype에 넣기
Array.prototype.함수 = function () {
    return "ham jjang"
}

console.log(어레이1.함수())

//------------------------------------------------------------//

//------------------------------------------------------------//
/*
자바스크립트는 클래스 기반 언어와 어떠한 차이?
- 상속을 사용하는 클래스 기반 언어와 다르게 자바스크립트는 프로토타입 기반 언어
- 프로토타입 기반 언어에서는 상속을 사용하지 않고 원형을 복제
*/
//------------------------------------------------------------//
