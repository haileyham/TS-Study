//------------------------------------------------------------//
// 타입스크립트 기본 타입 정리(primitive types)
//------------------------------------------------------------//
var 정리1 = 'hey';
//------------------------------------------------------------//
// Union Type : 타입 2개 이상 합친 새로운 타입
// 계산할 때 타입 에러 발생 가능(명확한 타입 아닐 때)
//------------------------------------------------------------//
var 유니언1 = 'hi';
var 유니언2 = [1, '2', 3];
var 오브젝트3 = { a: 123 };
//------------------------------------------------------------//
// any 타입 : 모든 자료형 허용
// unknown 타입 (any보다 안전)
// 두 개의 차이점은 에러 발생 유무 / 003 참고
//------------------------------------------------------------//
var 애니1; //아무거나 들어올 수 있음
var 언노운1; //아무거나 들어올 수 있음
//------------------------------------------------------------//
// 옵션 타입? : 타입
// 변수?:number는 변수:number|undefined와 같음
//------------------------------------------------------------//
//------------------------------------------------------------//005
// Type Narrowing : Type이 아직 하나로 확정되지 않았을 경우 사용
// typeof 연산자
// Narrwing / assertion
// [Narrowing으로 판정해주는 문법들]
// - typeof 변수
// - 속성명 in 오브젝트자료
// - 인스턴스 instanceof 부모
// > 현재 변수의 타입이 뭔지 특정지을 수 있기만 하면 다 인정
// [assertion 문법(타입 덮어쓰기)]
// - 변수 as type : 왼쪽에 있는 변수를 type으로 덮어쓰기 (ex) x as number : x변수를 number로 덮덮)
// 
// assertion 문법의 용도(안 혼나기 위해서 공뷰공뷰)
// 1. Narrowing 할 때 사용
// 2. 무슨 타입이 들어올지 100% 확실할 때 사용
//------------------------------------------------------------//
function 네로네로(x) {
    if (typeof x === 'number') { //type이 number일 경우
        return x + 1;
    }
    else {
        return x + '1';
    }
}
function 네로네로2(x) {
    var array = [];
    if (typeof x === 'number') { // number 아니고 "number"
        array[0] = x;
    }
    else {
    }
}
// assertion
// 변수 as type : 왼쪽에 있는 변수를 type으로 덮어쓰기 (ex) x as number : x변수를 number로 덮덮)
function 네로네로3(x) {
    var array = [];
    array[0] = x; // x를 number로 인식
}
// [1] Narrowing 할 때 사용
var 네로네로4 = 'ham';
// 밍 as number; //error : 타입을 a에서 b로 변경 x
// 만일 string|number였다면 가능 : Narrowing 할 때 사용하기 때문
// [2] 무슨 타입이 들어올지 100% 확실할 때 사용
function 네로네로5(x) {
    var array = [];
    array[0] = x; // x를 number로 인식
}
var 타타타1 = 'ham';
var 타타타2 = { name: 'ham', age: 100 };
var 포지션 = { x: 10, y: 20 };
var 리드온리동물1 = {
    name: 'cat'
};
// 리드온리동물1.name = 'dog' //변경하려고 하면, 에러 발생
//------------------------------------------------------------//
// Literal types : 특정 글자나 숫자만 가질 수 있또록 제한을 두는 타입
// 문제점은 객체에서 {name:'ham'}이라고 타입 지정할 경우 값이 ham이 들어오면 에러뜸. 왜냐하면 타입은 string이기 때문, 들어온 값의 타입이 'ham'이어야 함
/**
에러 안나도록
1. object 만들 때 타입지정 확실히
2. as 문법으로 타입 덮어쓰기
3. as const 키워드 사용
- 효과1 : object value 값을 타입으로 지정
- 효과2 : object 속성들에 모두 readonly 붙여줌
 */
//------------------------------------------------------------//
// 변수
var 리터럴1;
리터럴1 = '롤러코스터'; //'hello'넣으면 오류
// 함수
function 가위바위보자기(a) {
    return ['가위'];
}
가위바위보자기('보');
// 더해보기
function 햄타입만들어올수있따(a) {
}
//에러 안나도록 하려면?
//방법 1 : object 만들 때 타입지정을 확실히 
var 타입지정확실히 = {
    name: 'ham'
};
내함수네(자료1.name);
//방법 2 : as 문법으로 타입 덮어쓰기
내함수네(자료.name);
//방법3 : as const 키워드 사용 : 이 object는 literal type 지정 알아서 해주기
//as const 효과 1: object value 값을 그대로 타입으로 지정
//as const 효과 2: object 속성들에 모두 readonly 붙여줌(변경하면 에러나도록)
//object 자료를 완전히 잠가놓고 싶으면 as const 사용
var AsConst사용 = {
    name: 'ham'
};
//------------------------------------------------------------//
// array
//------------------------------------------------------------//
// 기본
// Union Type
//------------------------------------------------------------//
var 어레이1 = ['he', 'hi'];
//------------------------------------------------------------//
// object
//------------------------------------------------------------//
// 기본
// Union Type
//------------------------------------------------------------//
var 오브젝트1 = { age: 100 };
var 오브젝트2 = {
    member: ['ham', 'hailey'],
    days: 30,
    started: true,
};
//------------------------------------------------------------//
// 함수
//------------------------------------------------------------//
// 기본
// void 타입
//------------------------------------------------------------//
function 함수함수1(x) {
    return x * 2;
}
function 함수함수2(x) {
    1 + 1;
}
function 함수함수3(x) {
    console.log(x); //출력하면 x는 undefined로 나옴
}
