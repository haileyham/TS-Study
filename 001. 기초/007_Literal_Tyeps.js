//------------------------------------------------------------//
// Literal types
//------------------------------------------------------------//
// Literal types : 더 엄격한 타입지정 가능
// 변수에 뭐가 들어올지 더 엄격하게 관리 가능
// 특정 글자나 숫자만 가질 수 있또록 제한을 두는 타입(Literal types)
var 이름8; // 이름8에는 123만 들어올 수 있음
// 이름8 = 456; //에러뜸 123이 아니기 때문
//------------------------------------------------------------//
// 변수
var 놀이공원;
놀이공원 = '롤러코스터';
// 함수
function 함1(a) {
    return 1;
}
;
함1('hello'); //함수 파라미터에 들어올 수 있는 것들 제한했기에 다른 것 입력하면 에러
//------------------------------------------------------------//
function 가위바위보(a) {
    return ['가위'];
}
가위바위보('보');
//------------------------------------------------------------//
// Literal type은 const 변수와 유사하게 사용 가능
var 변수10 = 'ham'; //const 변수는 1개의 값만, 값을 바꿀 수 없는 변수
var 변수11; // 롤코or후룸 중에 하나 (const 변수 업글버전이라 생각)
//------------------------------------------------------------//
//------------------------------------------------------------//
// Literal type의 문제점
// as const 문법
//------------------------------------------------------------//
//Literal type의 문제점
var 자료 = {
    name: 'ham'
};
function 내함수네(a) {
}
내함수네('ham');
// 내함수네(자료.name); //에러 발생 / 자료.name은 'ham'이기는 하지만 type은 string임 / 내함수네 파라미터로 'ham'이라는 '타입'만 받고 있기 때문.
//------------------------------------------------------------//
/**
에러 안나도록
1. object 만들 때 타입지정 확실히
2. as 문법으로 타입 덮어쓰기
3. as const 키워드 사용
- 효과1 : object value 값을 타입으로 지정
- 효과2 : object 속성들에 모두 readonly 붙여줌
 */
//------------------------------------------------------------//
//에러 안나도록 하려면?
//방법 1 : object 만들 때 타입지정을 확실히 
var 자료1 = {
    name: 'ham'
};
내함수네(자료1.name); //위에서처럼 자료.name을 했지만 에러 발생안함 / 왜냐하면 object에 type을 ham타입으로 했기 때문
//방법 2 : as 문법으로 타입 덮어쓰기
내함수네(자료.name);
//방법3 : as const 키워드 사용 : 이 object는 literal type 지정 알아서 해주기
//as const 효과 1: object value 값을 그대로 타입으로 지정
//as const 효과 2: object 속성들에 모두 readonly 붙여줌(변경하면 에러나도록)
//object 자료를 완전히 잠가놓고 싶으면 as const 사용
var 자료2 = {
    name: 'ham'
};
// 자료2.name = 'hi' //as const가 readonly 효과 있기 때문에 변경하려면 에러발생
내함수네(자료2.name);
