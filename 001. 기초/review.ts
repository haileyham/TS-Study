//------------------------------------------------------------//
// 타입스크립트 기본 타입 정리(primitive types)
//------------------------------------------------------------//

let 정리1: string = 'hey';



//------------------------------------------------------------//
// Union Type : 타입 2개 이상 합친 새로운 타입
// 계산할 때 타입 에러 발생 가능(명확한 타입 아닐 때)
//------------------------------------------------------------//

let 유니언1: (number | string) = 'hi';
let 유니언2: (number|string)[] = [1, '2', 3];
let 오브젝트3: { a: number | string } = { a: 123 };



//------------------------------------------------------------//
// any 타입 : 모든 자료형 허용
// unknown 타입 (any보다 안전)
// 두 개의 차이점은 에러 발생 유무 / 003 참고
//------------------------------------------------------------//

let 애니1: any; //아무거나 들어올 수 있음
let 언노운1: unknown; //아무거나 들어올 수 있음



//------------------------------------------------------------//
// 옵션 타입? : 타입
// 변수?:number는 변수:number|undefined와 같음
//------------------------------------------------------------//



//------------------------------------------------------------//005
// Type Narrowing : Type이 아직 하나로 확정되지 않았을 경우 사용
// typeof 연산자
// Narrwing / assertion

// [Narrowing으로 판정해주는 문법들]
// - typeof 변수
// - 속성명 in 오브젝트자료
// - 인스턴스 instanceof 부모
// > 현재 변수의 타입이 뭔지 특정지을 수 있기만 하면 다 인정

// [assertion 문법(타입 덮어쓰기)]
// - 변수 as type : 왼쪽에 있는 변수를 type으로 덮어쓰기 (ex) x as number : x변수를 number로 덮덮)
// 
// assertion 문법의 용도(안 혼나기 위해서 공뷰공뷰)
// 1. Narrowing 할 때 사용
// 2. 무슨 타입이 들어올지 100% 확실할 때 사용

//------------------------------------------------------------//

function 네로네로(x: number | string) {
    if (typeof x === 'number') {//type이 number일 경우
        return x + 1;
    } else {
        return x + '1';
    }
} 

function 네로네로2( x: number | string) {
    let array: number[] = [];
    if (typeof x === 'number') { // number 아니고 "number"
        array[0] = x;
    } else {
        
    }
    
}

// assertion
// 변수 as type : 왼쪽에 있는 변수를 type으로 덮어쓰기 (ex) x as number : x변수를 number로 덮덮)
function 네로네로3(x : number|string) {
    let array: number[] = []
    array[0] = x as number; // x를 number로 인식
}

// [1] Narrowing 할 때 사용
let 네로네로4: string = 'ham';
// 밍 as number; //error : 타입을 a에서 b로 변경 x
// 만일 string|number였다면 가능 : Narrowing 할 때 사용하기 때문

// [2] 무슨 타입이 들어올지 100% 확실할 때 사용
function 네로네로5(x : number|string) {
    let array: number[] = []
    array[0] = x as number; // x를 number로 인식
}



//------------------------------------------------------------//
// / type alias (타입변수) 만드는 법
// type 변수 작명 관습 : 영어대문자 시작 / 뒤에 Type 붙이기 (AnimalType)
// type변수 : union type으로 합치기 가능 / OR 연산자 통해서 Union type 만들기
// & 연산자로 object 타입 합치기(사실상 &연산자로 둘다만족하는 것)
// interface랑 비교
//------------------------------------------------------------//

type 타입변수다1 = string | number | undefined; //AnimalType 하면 조금 더 정확
let 타타타1: 타입변수다1 = 'ham';

type 타입변수다2Type= { name?: string, age?: number } //obeject 속성안에도 ? 사용가능
let 타타타2: 타입변수다2Type = { name: 'ham', age: 100 }

// &
type 타입변수X = { x: number };
type 타입변수Y = { y: number };
type 뉴타입XY = PositionX & PositionY; // = {x : number, y : number}

let 포지션: NewType = { x: 10, y: 20 };



//------------------------------------------------------------//
// readonly : const 객체 재할당 잠그기
//------------------------------------------------------------//

// readonly 사용하여 object 자료 수정 막기
type 리드온리1 = {
    readonly name : string // 변수 타입지정할 때 실수로 수정하면 에러발생시킴 / 예를들면 
}

const 리드온리동물1 : 리드온리1 = { //이렇게 리드온리동물1.name 이미 cat으로 넣었는데
    name : 'cat'
}
// 리드온리동물1.name = 'dog' //변경하려고 하면, 에러 발생



//------------------------------------------------------------//
// Literal types : 특정 글자나 숫자만 가질 수 있또록 제한을 두는 타입
// 문제점은 객체에서 {name:'ham'}이라고 타입 지정할 경우 값이 ham이 들어오면 에러뜸. 왜냐하면 타입은 string이기 때문, 들어온 값의 타입이 'ham'이어야 함
/**
에러 안나도록
1. object 만들 때 타입지정 확실히
2. as 문법으로 타입 덮어쓰기
3. as const 키워드 사용
- 효과1 : object value 값을 타입으로 지정
- 효과2 : object 속성들에 모두 readonly 붙여줌
 */
//------------------------------------------------------------//

// 변수
let 리터럴1: '롤러코스터' | '후룸라이드';
리터럴1 = '롤러코스터'; //'hello'넣으면 오류

// 함수
function 가위바위보자기(a: '가위' | '바위' | '보'): ('가위' | '바위' | '보')[]{//파라미터랑 리턴값으로 해당 타입만 들어올 수 있음
    return ['가위'];
}
가위바위보자기('보')


// 더해보기
function 햄타입만들어올수있따(a : 'ham') { //'ham'이라는 자료만 들어올 수 있음(x)/'ham'이라는 타입만 들어올 수 있음(O)
    
}

//에러 안나도록 하려면?
//방법 1 : object 만들 때 타입지정을 확실히 
let 타입지정확실히: {//타입지정을 ham으로
    name : 'ham'
} = {
    name : 'ham'
}
내함수네(자료1.name); 

//방법 2 : as 문법으로 타입 덮어쓰기
내함수네(자료.name as 'ham')

//방법3 : as const 키워드 사용 : 이 object는 literal type 지정 알아서 해주기
//as const 효과 1: object value 값을 그대로 타입으로 지정
//as const 효과 2: object 속성들에 모두 readonly 붙여줌(변경하면 에러나도록)
//object 자료를 완전히 잠가놓고 싶으면 as const 사용
let AsConst사용 = {
    name : 'ham'
} as const; 



//------------------------------------------------------------//
// array
//------------------------------------------------------------//
// 기본
// Union Type
//------------------------------------------------------------//


let 어레이1: string[] = ['he', 'hi'];



//------------------------------------------------------------//
// object
//------------------------------------------------------------//
// 기본
// Union Type
//------------------------------------------------------------//

let 오브젝트1: { age: number } = { age: 100 }

let 오브젝트2: {
    member: string[],
    days: number,
    started: boolean,
} = {
    member: ['ham', 'hailey'],
    days: 30,
    started: true,
}



//------------------------------------------------------------//
// 함수
//------------------------------------------------------------//
// 기본
// void 타입
//------------------------------------------------------------//

function 함수함수1( x:number):number { //파라미터 number, return number로 지정
    return x * 2;
}

function 함수함수2( x:number):void { //실수로 return하는 걸 사전에 막을 수 있음
    1 + 1
}

function 함수함수3( x?:number):void { //파라미터변수? : 타입 // number|undefined
    console.log(x); //출력하면 x는 undefined로 나옴
}