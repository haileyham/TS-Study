// Union Type : 타입 2개 이상 합친 새로운 타입
var 회원1 = 123;
var 회원2 = 'ham';
회원1; //number
회원2; //string
var 회원들 = [1, '2', 3];
var 오브젝트 = { a: 123 };
//------------------------------------------------------------//
// any 타입 : 모든 자료형 허용
// 타입스크립트 쓰는 의미가 사라질 수 있으니, 타입실드를 해제하는 문법이라 생각
// 일반 JS 변수로 만들어 사용할 때 
// 타입관련 버그가 나도 잡아주지 못함
var 회원3; //아무거나 들어올 수 있음
회원3 = 123;
회원3 = [];
// 에러를 발생시켜주지 않음ㅠ : 위에서 회원 3는 []로 되어있고, 변수1은 string이어서 맞지 않지만 에러를 발생시켜주지 않음. any이기 때문에 말그대로 아무거나 올 수 있기 때문
var 변수1 = 회원3;
//------------------------------------------------------------//
// unknown 타입 (any보다 안전)
var 회원4;
회원4 = 123;
회원4 = {};
// 에러 발생 : 위에서 회원 4 {} 되어있고, 변수2는 string이기 때문에 맞지 않음
// let 변수2: string = 회원4;
// 정상 작동 : 위에서 회원 4 {}, 변수3도 {} 이기 때문
var 변수3 = 회원4;
//------------------------------------------------------------//
//타입스크립트의 엄격함에 대해 (중요) 간단한 수학연산도 타입이 맞아야 함
//Why 타입 맞는데 +1이 안됑? > 타입스크립트는 타입 엄격한 것 좋아하기 때문
var 계산; //union type은 새로운타입을 만들어 내는 것
// 계산 + 1; //error
//string타입 + 1 (O)
//number타입 + 1 (O)
//string | number 타입 + 1 (X)
var 계산1 = '123';
var 계산2 = 123;
계산1 + 1; //'1234'
계산2 + 1; //124
//------------------------------------------------------------//
var 계산3 = 1;
//error
//숫자타입이여야 숫자처럼 연산함. unknown이 왔기 때문에
// 계산3 - 1;
//에러가 나는 코드들은 나중에 Narrowing / Assertion을 통해 엄격하게 코드 짜기
